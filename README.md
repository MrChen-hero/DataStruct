# 数据结构与算法 DataStruct  

## 第八章 排序  

### 8.1 内部排序总结

| 排序方法       | 时间复杂度(最好) | 时间复杂度(最坏) | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 每趟是否确定一个元素的最终位置|
| -------------- | --------------- | --------------- | --------------- | ---------- | ------ | :----: |
| 直接插入排序   | $O(n)$          | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 稳定   | 每一趟排序会使表内元素局部有序    |
| 折半插入排序   | $O(n)$          | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 稳定   | 每一趟排序会使表内元素局部有序    |
| 希尔排序       |     |   | 依赖于序列     | $O(1)$     | 不稳定 | 每一趟排序会使表内元素局部有序      |
| 冒泡排序       | $O(n)$          | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 稳定   | 每趟都确保表中最大(最小)元素在其最终位置    |
| 快速排序       | $O(n\log n)$    | $O(n^2)$        | $O(n\log n)$    | $O(\log n)$| 不稳定 | 每一趟排序能确定基准元素的最终位置    |
| 简单选择排序   | $O(n^2)$        | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 不稳定 | 每趟都确保表中最大(最小)元素在其最终位置    |
| 堆排序         | $O(n\log n)$    | $O(n\log n)$    | $O(n\log n)$    | $O(1)$     | 不稳定 | 每趟都确保表中最大(最小)元素在其最终位置   |
| 二路归并排序   | $O(n\log n)$    | $O(n\log n)$    | $O(n\log n)$    | $O(n)$     | 稳定   | 否    |
| 基数排序       | $O(d(n+r))$     | $O(d(n+r))$    | $O(d(n+r))$     | $O(r)$      | 稳定   | 否    |

### 8.2 插入排序

#### 直接插入排序

**【算法描述】**

1. 从第一个元素开始，该元素默认已经是有序区。
2. 取下一个元素，将该元素搬到有序区中，插入到合适的位置。
3. 重复第2步，直到所有元素遍历完毕。

**【性能分析】**

- 最好情况：输入序列已经是有序，遍历一遍即可，时间复杂度为$O(n)$。
- 最坏情况：输入序列完全逆序，每次插入都要移动元素，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**

- 当顺序表已经是有序时，每个元素只需比较一次，共n-1次。公式为：$C_{\text{min}}(n) = n - 1$。

**【最坏情况下的比较次数】**

- 当顺序表完全逆序时，第i个元素需要和前i-1个元素进行比较，共$ \frac{n(n-1)}{2} $次。公式为：$C_{\text{max}}(n) = \frac{n(n-1)}{2}$。

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都使得表中元素局部有序

#### 折半插入排序

**【算法描述】**

1. 从第一个元素开始，该元素默认已经是有序区。
2. 取下一个元素，在有序区中使用二分查找找到合适的插入位置。
3. 插入到找到的位置，移动插入点后的元素。
4. 重复第2步和第3步，直到所有元素遍历完毕。

**【性能分析】**

- 最好情况：输入序列已经是有序，时间复杂度为$O(n)$。
- 最坏情况：输入序列完全逆序，需要进行多次二分查找，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**

- 当顺序表已经是有序时，每个元素只需通过二分查找法找到插入的位置，共$log_{2} n$次。公式为：$C_{\text{min}}(n) = \log_{2} n$。

**【最坏情况下的比较次数】**

- 当顺序表完全逆序时，每个元素都要通过二分查找法找到插入的位置，共$n\log_{2} n$次。公式为：$C_{\text{max}}(n) = n \log_{2} n$。

**【稳定性】**  稳定。

**【适用性】** 适用于顺序存储和链式存储。但由于涉及到元素的大量移动，链式存储的效率会降低。

**【过程特性】** 每趟都使得表中元素局部有序

#### 希尔排序

**【算法描述】**

1. 设置增量序列，如希尔增量：$d = n / 2, d = d / 2, \dots, d = 1$。
2. 按增量划分子序列，利用插入排序对子序列进行排序。
3. 缩小增量，重复第2步，直到增量为1。

**【性能分析】**

- 具体取决于所选的增量序列。

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。但是由于对子序列进行插入排序，链式存储的效率会降低。

**【过程特性】** 每趟都使得表中元素局部有序

### 8.3 交换排序

#### 冒泡排序

**【算法描述】**

1. 从数组的第一个元素开始，遍历数组，在相邻的元素中进行比较，如果逆序，则交换它们的位置。
2. 重复进行第1步，直到整个数组都有序。

**【性能分析】**

- 最好情况：输入序列已经是有序，遍历一遍即可，时间复杂度为$O(n)$。
- 最坏情况：输入序列完全逆序，需要进行n-1轮比较，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**

- 当顺序表已经是有序时，比较次数 n-1，移动次数 0。

**【最坏情况下的比较次数】**

- 当顺序表完全逆序时，比较次数 $\frac{n(n-1)}{2}$，移动次数 $\frac{3n(n-1)}{2}$

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都确保表中最大(最小)元素在其最终位置

#### 快速排序

**【算法描述】**

1. 选择一个基准元素（如数组的第一个元素）。
2. 将数组中的元素按照跟基准元素的比较结果进行分区（比基准元素小的在左边，大的在右边）。
3. 递归地分别对左右两边的子数组进行第2步，直到子数组只剩一个元素或空。

**【性能分析】**

- 最好情况：每次选取的基准元素将数组均分，时间复杂度为$O(n\log n)$。
- 最坏情况：每次选取的基准元素都是最大或最小，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 第i趟完成后，会有i个以上的元素出现在最终位置，即它左边的数比它小，右边的数比它大

### 8.4 选择排序

#### 简单选择排序

**【算法描述】**

1. 在待排序的序列中找到最小值。
2. 将找到的最小值替换序列中的第一个元素。
3. 从剩下未排序的序列中重复第1步与第2步，直到序列全部排序完毕。

**【性能分析】**

- 无论是最好还是最坏情况下，时间复杂度均为$O(n^2)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都确保表中最大(最小)元素在其最终位置

#### 堆排序

**【算法描述】**

1. 将无序序列构建成一个大顶堆（或小顶堆）。
2. 将堆顶元素与序列的最后一个元素交换。
3. 缩小待排序序列的范围，去掉最后一个元素，重新调整堆结构。
4. 重复第2步与第3步，直到整个序列排序完成。

**【性能分析】**

- 无论是最好还是最坏情况下，时间复杂度均为$O(n\log n)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都确保表中最大(最小)元素在其最终位置

### 8.5 二路归并排序

**【算法描述】**

1. 将待排序数组分成两个长度相等的子数组。
2. 递归地对两个子数组进行归并排序，直到每个子数组只剩下一个元素。
3. 将两个已排序的子数组合并成一个有序数组。

**【性能分析】**

- 无论是最好还是最坏情况下，时间复杂度均为$O(n\log n)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

### 8.6 基数排序

**【算法描述】** 

1. 根据元素的位数（比如个位、十位、百位等）从低到高进行排序。
2. 在每一位上，采用一个稳定的排序算法（如计数排序）对数字进行排序。
3. 对所有位数重复进行第1步与第2步，直到最高位排序完成。

**【性能分析】**

- 最好情况：输入序列中的元素分布均匀，时间复杂度为$O(d(n+r))$，k为最大元素的位数。
- 最坏情况：输入序列中的元素非常集中，需要进行额外的桶排序，时间复杂度仍为$O(d(n+r))$。
- 基数排序的时间复杂度中的d表示关键字的位数，r表示关键字的基数或者范围3。例如，如果关键字是十进制数，那么r=10，如果关键字是英文字母，那么r=26。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

### 8.7 外部排序

**【外部排序的总时间】**

外部排序的总时间 = 内部排序所需时间 + 外存信息读写时间 + 内部归并所需时间

#### 多路平衡与败者树

**【算法描述】**

- 构建一个k路败者树，k表示归并的路数，败者树的叶子节点对应从输入缓冲区读取的顺序记录。
- 输赢规则：较小的数为胜者，较大的数为败者。
- 在败者树上选择胜者（最小记录），将胜者输出到输出缓冲区。
- 将胜者所在的归并段中的下一个顺序记录读取，并重新调整败者树结构。
- 当所有输如缓冲区数据合并完毕则结束外部排序。

**【比较次数】** 最多为$C = S \times (n-1) \times \lceil \log_2 k \rceil$，k为归并的路数。

#### 置换选择排序

**【算法描述】**

1. 初始化一个最小值，完成初始化准备。
2. 遍历所有输入缓冲区记录，选择大于当前最小值的最小记录，并输出到输出缓冲区。
3. 如果当前输入缓冲区读完，重新填充缓冲区。
4. 持续步骤2-3，直至输入缓冲区全部读完并且没有可以替换的记录。

**【比较次数】**

- 比较次数不确定，因为与输入数据密切相关。如果原始数据越接近有序，比较次数就越少。

#### 最佳归并树

**【算法描述】**

- 计算每个归并段的长度，作为权重。
- 使用霍夫曼树构建最佳归并树，使每个归并段完成的I/O次数最小。
- 将归并树的叶子节点按照顺序合并。

**【如何判断添加虚段的次数？】**

- 对于k路平衡归并来说，若(m-1)MOD(k-1)=0，则不需要增加虚段；否则需附加k-(m-1)MOD(k-1)-1个虚段。

### 8.8 排序算法的分析与应用

1. 冒泡排序 (Bubble Sort):
    - 适用场景：小规模数据，局部有序，链式存储。
    - 优点：实现简单，相邻数据交换，稳定。
    - 缺点：时间复杂度较高，不适用于大规模数据。

2. 选择排序 (Selection Sort):
    - 适用场景：小规模数据，对算法稳定性要求不高。
    - 优点：实现简单，无论数据如何都能保证最多$n-1$次数据交换。
    - 缺点：不稳定，不适应于有序和接近有序的数据。

3. 插入排序 (Insertion Sort):
    - 适用场景：小规模数据，接近有序。
    - 优点：实现简单，时间复杂度在接近有序数据时较低，稳定。
    - 缺点：不适用于大规模数据。

4. 快速排序 (Quick Sort):
    - 适用场景：大规模数据，速度较快。
    - 优点：平均时间复杂度较低，为$O(n\log n)$，适用于各种内存储结构。
    - 缺点：最坏情况时间复杂度较高，为$O(n^2)$，不稳定。

5. 归并排序 (Merge Sort):
    - 适用场景：大规模数据，稳定性要求较高。
    - 优点：时间复杂度为$O(n\log n)$，适用于各种内存储结构，稳定。
    - 缺点：辅助空间消耗较高，需要额外的空间来完成归并操作。

6. 堆排序 (Heap Sort):
    - 适用场景：大规模数据，要求原地排序。
    - 优点：时间复杂度为$O(n\log n)$，适用于各种内存储结构，原地排序。
    - 缺点：不稳定，局部排序性较差。

7. 希尔排序 (Shell Sort):
    - 适用场景：中等规模数据。
    - 优点：对插入排序的改进，适用于增量序列较小的情况，实现相对简单。
    - 缺点：增量序列的选择对算法性能有较大影响，不稳定。

8. 基数排序 (Radix Sort):
    - 适用场景：数据长度较大，元素分布已知。
    - 优点：时间复杂度较低，稳定。
    - 缺点：辅助空间消耗较高，需要额外的空间来分配元素到相应的序列中。
