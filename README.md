# 数据结构与算法 DataStruct  

## 第一章 绪论

## 第二章 线性表

## 第三章 栈和队列

## 第四章 串

## 第五章 树和二叉树

## 第六章 图

## 第七章 查找

### 7.1 查找的基本概念

#### 查找的定义

- 查找是在一组数据元素（通常称为查找表）中，找出满足某种条件的数据元素（或称为关键字）的过程。
- 查找表。由同一类型的数据元素（或记录）构成的集合。
  - 查找表进行的操作一般有四种：1. 插入；2. 删除；3. 修改；4. 查找。
- 静态查找表。只做查找操作的查找表。
- 关键字。数据元素中唯一标识该元素的数据项。
- 平均查找长度（ASL）。查找成功时，需要比较的次数的期望值。
  - ASL = $\sum_{i=1}^{n} p_i c_i$
  - 其中$p_i$为查找表中第i个数据元素的概率，$c_i$为查找第i个数据元素时需要比较的次数。

### 7.2 顺序查找和折半查找

#### 顺序查找

**【算法描述】**

1. 从第一个元素开始，依次与给定值进行比较。
2. 如果相等，则查找成功，返回元素下标。
3. 如果不相等，则继续向后查找，直到查找完毕。

**【性能分析】**

- 最好情况：第一个元素就是要查找的元素，时间复杂度为$O(1)$。
- 最坏情况：最后一个元素才是要查找的元素，时间复杂度为$O(n)$。

**【平均查找长度】**

- 查找成功时的平均查找长度为：$ASL = \sum_{i=1}^{n} P_i(n-i+1) = \frac{n+1}{2}$。

**【有序表的顺序查找判定树】**

- 有序表的顺序查找判定树是一棵二叉树，它的每个结点都是一个判定结点，每个判定结点都包含一个关键字域和两个分支域。
- 有序表的顺序查找判定树的特点是：左分支域中的关键字均小于判定结点的关键字，右分支域中的关键字均大于判定结点的关键字。
- 失败节点的个数为：$n+1$。
  - 查找不成功的平均查找长度为：$ASL = \sum_{j=1}^{n} P_j(l_j - 1) = \frac{1+2+...+n}{n+1}$ = $\frac{n}{2} + \frac{n}{n+1}$。
  - 其中&P_j&表示查找不成功时，第j个结点的概率，&l_j&表示查找不成功时，第j个失败结点的深度。

**【适应性】** 适用于顺序存储和链式存储。

#### 折半查找

**【算法描述】**

1. 从有序表的中间位置开始，将给定值与中间位置的元素进行比较。
2. 如果相等，则查找成功，返回元素下标。
3. 如果不相等，则根据给定值与中间位置元素的大小关系，确定下一次查找的范围。
4. 重复第1步和第2步，直到查找完毕。

**【性能分析】**

- 最好情况：第一个元素就是要查找的元素，时间复杂度为$O(1)$。
- 最坏情况：最后一个元素才是要查找的元素，时间复杂度为$O(\log n)$。

**【平均查找长度】**

- 查找成功时的平均查找长度为：$ASL = \frac{1}{n} \sum_{i=1}^{n} l_i  = \frac{n+1}{n} \log_{2} n$。

**【折半查找判定树】**

- 折半查找判定树是一棵平衡二叉树

**【适应性】** 仅适用于顺序存储结构。

#### 分块查找

**【算法描述】**

1. 将查找表分成若干块，每一块中的元素不必有序，但块与块之间必须有序。
2. 先对块进行二分查找(或顺序查找)，确定待查元素在哪一块中。
3. 再在确定的块中进行顺序查找，找到待查元素。

**【性能分析】**

- 最好情况：第一个元素就是要查找的元素，时间复杂度为$O(1)$。
- 最坏情况：最后一个元素才是要查找的元素，时间复杂度为$O(\sqrt{n})$。

**【平均查找长度】**

- 查找成功时的平均查找长度为：$ASL = L_i + L_s = \frac{b+1}{2} + \frac{s+1}{2} = \frac{s^2+2s+n}{2}$
  - 其中$b$表示分成的块数，$s$表示每块有n个记录，$n$表示表的总长度。
  - 此时若$s = \sqrt{n}$，则$ASL = \sqrt{n} + 1$。

**【适应性】** 适用于顺序存储和链式存储。

### 7.3 树形查找

#### 二叉排序树

**【二叉排序树的定义及性质】**

- 二叉排序树。或者是一棵空树，或者是具有下列性质的二叉树：
  - 若左子树不空，则左子树上所有结点的值均小于它的根结点的值。
  - 若右子树不空，则右子树上所有结点的值均大于它的根结点的值。
  - 左、右子树也分别为二叉排序树。
- 左 < 根 < 右
- 根据二叉排序树的性质，中序遍历二叉排序树，得到的序列是递增有序的。

**【二叉排序树的构造】**

- 二叉树的插入
  - 如果二叉排序树为空，则插入的结点为根结点。
  - 如果二叉排序树不为空，则从根结点开始，将待插入结点与根结点进行比较。
    - 如果待插入结点的值小于根结点的值，则继续与根结点的左子树进行比较。
    - 如果待插入结点的值大于根结点的值，则继续与根结点的右子树进行比较。
    - 如果待插入结点的值等于根结点的值，则不插入。
    - 如果待插入结点的左子树或右子树为空，则将待插入结点插入到该位置。
    - 如果待插入结点的左子树和右子树都不为空，则继续与左子树或右子树的根结点进行比较，直到找到合适的位置。
- 二叉树的删除
  - 如果待删除结点的左子树和右子树都为空，则直接删除该结点。
  - 如果待删除结点的左子树(或右子树)为空，则将待删除结点的子树作为其父结点的左子树，代替父节点的位置。
  - 如果待删除结点的左子树和右子树都不为空，则将待删除结点的直接后继(或直接前驱)结点的值赋给待删除结点，然后删除直接后继(或直接前驱)结点。

**【性能分析】**

- 最好情况：二叉排序树的形态与完全二叉树的形态相同，时间复杂度为$O(\log n)$。
- 最坏情况：二叉排序树的形态是倾斜的单只树，时间复杂度为$O(n)$。

**【平均查找长度】**

- 查找成功时的平均查找长度为：$ASL =\frac{1}{n} \sum_{i=1}^{n}(H_i*N_i)$
  - 其中$H_i$为第i个结点的高度，$N_i$为查找表中在高度$H_i$下的结点数量。

**【适应性】** 适用于顺序存储和链式存储。

#### 平衡二叉树

**【平衡二叉树的定义及性质】**

平衡二叉树，又称AVL树，是一种特殊的二叉搜索树。每个节点具有一个平衡因子，它是其左子树高度与右子树高度之差。该平衡因子应在{-1, 0, 1}范围内。平衡二叉树的主要特性是支持保持查找的平衡性，从而提高查找效率。

**【平衡二叉树的构造】**

1. LL：平衡因子失衡的节点是结点A的左子树根结点B的左子树，结点B右旋。
2. RR：平衡因子失衡的节点是结点A的右子树根结点B的右子树，结点B左旋。
3. LR：平衡因子失衡的节点是结点A的左子树根结点B的右子树根节点C上，结点C先左旋后右旋。
4. RL：平衡因子失衡的节点是结点A的右子树根结点B的左子树根节点C上，结点C先右旋后左旋。

**【性能分析】**

查询、插入和删除时间复杂度为$O(\log n)$。空间复杂度为$O(n)$。

**【平均查找长度】**

AVL树的查找长度近似等于$\log_2 n$。

**【适应性】**

适用于顺序存储和链式存储。AVL树特别适合执行大量查找的操作。

#### 红黑树

**【红黑树的定义及性质】**

红黑树是一种特殊的二叉搜索树，满足以下性质：

1. 每个节点或者是红色，或者是黑色。
2. 根节点是黑色。
3. 每个叶子节点（NIL）是黑色。
4. 如果一个节点是红色的，则它的两个子节点都是黑色的。
5. 对于每个节点，从该节点到其所有后代叶子节点的简单路径上，黑色节点的数量相同。

- 结论1：从根到叶结点的最长路径不大于最短路径的2倍
- 结论2：红黑树的高度不大于$2\log_2(n+1)$

**【红黑树的构造】**

- 插入：新插入的节点默认为红色，为满足红黑树的性质，可能需要进行旋转和颜色调整。
  1. 如果插入的节点z是根节点，则将其颜色设置为黑色。
  2. 如果插入的节点z的父节点是黑色，则不需要进行调整。
  3. 如果插入的节点z的父节点是红色，则需要进行调整。
     - 如果z的叔叔节点y是红色，则将z的父节点和叔叔节点都设置为黑色，将z的祖父节点设置为红色，然后将z的祖父节点设置为当前节点，继续进行调整。
     - 如果z的叔叔节点y是黑色，则需要进行旋转和颜色调整。
        - LR：z是其祖父节点的左孩子的右孩子，先做对z一次左旋，在做一次右旋，然后将z与其祖父结点染色。
        - LL：z是其祖父节点的左孩子的左孩子，对z的父节点做一次右旋，然后将其与z原来的祖父节点染色。

- 删除：删除节点后，为维持红黑树的性质，可能需要进行旋转和颜色调整。

**【性能分析】**

查询、插入和删除时间复杂度为$O(\log n)$。空间复杂度为$O(n)$。

**【平均查找长度】**

红黑树的查找长度近似等于$\log_2 n$。

**【适应性】**

适用于顺序存储和链式存储。红黑树特别适合执行大量插入、删除和查找的操作。

### 7.4 B树和B+树

#### B树及其基本操作

**【B树的定义及性质】**

B树是一种平衡的多路搜索树，具有以下几个性质：

1. 每个节点最多包含m个子节点。
2. 每个内部节点（除根和叶子外）的子节点数至少为$⌈m/2⌉$。
3. 根节点的子节点数可以在[2, m]范围内。
4. 除根节点外，所有节点存放至少$⌈m/2⌉-1$个关键字。
5. 关键字储存在节点中，并且从小到大排序。

**【B树的性质】**

1. B树具有良好的平衡性，查找、插入和删除操作性能良好。
2. 适用于外部存储，因为节点可以容纳大量关键字，从而减少IO次数。

**【性能分析】**

查询、插入和删除时间复杂度约为$O(\log_m n)$，其中m为B树的分支因子。空间复杂度为$O(n)$。

**【平均查找长度】**

B树的查找长度近似等于$\log_m n$。

**【适应性】**

适用于顺序存储和链式存储。B树特别适合在外部存储设备中存储和查找大量数据。

#### B+树的基本概念

**【B+树的定义及性质】**

B+树是B树的一种变体，具有以下几个性质：

1. 有k个子树的节点包含k个关键字。
2. 所有的叶子节点包含全部关键字的信息，及指向记录的指针和指向直接后继节点的指针。叶子节点从左到右是有序的。
3. 内部节点仅包含对儿子节点的索引，所有关键字信息都在叶子节点。

**【性能分析】**

查询、插入和删除时间复杂度约为$O(\log_m n)$，其中m为B+树的分支因子。空间复杂度为$O(n)$。

**【平均查找长度】**

B+树的查找长度近似等于$\log_m n$。

**【适应性】**

适用于顺序存储和链式存储。B+树特别适合用于在外部存储设备中存储和查找大量数据，因为所有关键字信息都在叶子节点，范围查找更加高效。

**【B树与B+树的直接区别】**

B+树的所有非叶子节点仅用作索引，不存储实际数据；B+树的所有叶子节点都存储实际数据，并且通过指针相连形成一个链表；B+树的每个节点存储的关键字个数与子节点个数相等。

### 7.5 散列查找

#### 散列表的基本概念

- 散列函数。将查找表中的关键字映射到散列表中的地址的函数。
- 散列地址。散列函数计算得到的地址。
- 散列冲突。不同的关键字通过散列函数计算得到的散列地址相同的现象。

#### 散列函数的构造方法

- 直接定址法。$H(key) = a \times key + b$。
- 数字分析法。分析关键字中各位上的数字，选取其中冲突较少的几位作为散列地址。
- 平方取中法。取关键字平方后的中间几位作为散列地址。
- 折叠法。将关键字分割成位数相同的几部分，然后取这几部分的叠加和（舍去进位）作为散列地址。
- 除留余数法。$H(key) = key \mod p$，其中$p$为不大于散列表长度的最大质数。
- 随机数法。取关键字的随机函数值作为散列地址。

#### 处理冲突的方法

- 开放定址法。当发生冲突时，根据某种规则去寻找下一个空的散列地址。
  - 线性探测法。$H(key) = (H(key) + d) \mod m$，其中$d$为增量序列，$m$为散列表长度。
  - 平方探测法。$H(key) = (H(key) + d_i) \mod m$，其中$d_i = \pm 1^2, \pm 2^2, \pm 3^2, \dots, \pm i^2$。
  - 双散列法。当发生冲突时，计算另一个散列函数，直到找到空的散列地址。
  - 随机探测法。$H(key) = (H(key) + d_i) \mod m$，其中$d_i$为随机数列。
- 链地址法。将所有散列到同一个地址的元素都存储在一个链表中。

#### 散列查找及其性能分析

**【算法描述】**

1. 根据给定的关键字计算散列地址。
2. 如果散列地址中的元素为空，则查找失败。
3. 如果散列地址中的元素不为空，则比较关键字是否相等。
4. 如果关键字相等，则查找成功，返回元素下标。
5. 如果关键字不相等，则根据处理冲突的方法，计算下一个散列地址。
6. 重复第2步到第5步，直到查找成功或者查找失败。

**【性能分析】**

- 最好情况：散列函数计算得到的散列地址不冲突，时间复杂度为$O(1)$。
- 最坏情况：散列函数计算得到的散列地址都冲突，时间复杂度为$O(n)$。

**【平均查找长度】**

- 查找成功时的平均查找长度为：$ASL = \sum_{i=1}^{n} P_i (1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n}) = \sum_{i=1}^{n} P_i H_i$。
  - 其中$P_i$为查找表中第i个数据元素的概率，$H_i$为查找第i个数据元素时需要比较的次数。
  - 当散列表长度$m$足够大时，$H_i \approx \ln n$，则$ASL \approx \sum_{i=1}^{n} P_i \ln n = \ln n$。
- 查找不成功时的平均查找长度为：$ASL = \sum_{i=1}^{n} P_i (1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n}) = \sum_{i=1}^{n} P_i H_i$。
  - 其中$P_i$为查找表中第i个数据元素的概率，$H_i$为查找第i个数据元素时需要比较的次数。
  - 当散列表长度$m$足够大时，$H_i \approx \frac{1}{1-P_0}$，则$ASL \approx \sum_{i=1}^{n} P_i \frac{1}{1-P_0} = \frac{1}{1-P_0}$。

## 第八章 排序  

### 8.1 内部排序总结

| 排序方法       | 时间复杂度(最好) | 时间复杂度(最坏) | 时间复杂度(平均) | 空间复杂度 | 稳定性 | 每趟是否确定一个元素的最终位置|
| :----: | :----: | :----: | :----: | :----: | :----: | :----: |
| 直接插入排序   | $O(n)$          | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 稳定   | 每一趟排序会使表内元素局部有序    |
| 折半插入排序   | $O(n)$          | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 稳定   | 每一趟排序会使表内元素局部有序    |
| 希尔排序       |     |   | 依赖于序列     | $O(1)$     | 不稳定 | 每一趟排序会使表内元素局部有序      |
| 冒泡排序       | $O(n)$          | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 稳定   | 每趟都确保表中最大(最小)元素在其最终位置    |
| 快速排序       | $O(n\log_{2}n)$    | $O(n^2)$        | $O(n\log_{2} n)$    | $O(\log_{2} n)$| 不稳定 | 每一趟排序能确定基准元素的最终位置    |
| 简单选择排序   | $O(n^2)$        | $O(n^2)$        | $O(n^2)$        | $O(1)$     | 不稳定 | 每趟都确保表中最大(最小)元素在其最终位置    |
| 堆排序         | $O(n\log_{2} n)$    | $O(n\log_{2} n)$    | $O(n\log_{2} n)$    | $O(1)$     | 不稳定 | 每趟都确保表中最大(最小)元素在其最终位置   |
| 二路归并排序   | $O(n\log_{2} n)$    | $O(n\log_{2} n)$    | $O(n\log_{2}n)$    | $O(n)$     | 稳定   | 否    |
| 基数排序       | $O(d(n+r))$     | $O(d(n+r))$    | $O(d(n+r))$     | $O(r)$      | 稳定   | 否    |

### 8.2 插入排序

#### 直接插入排序

**【算法描述】**

1. 从第一个元素开始，该元素默认已经是有序区。
2. 取下一个元素，将该元素搬到有序区中，插入到合适的位置。
3. 重复第2步，直到所有元素遍历完毕。

**【性能分析】**

- 最好情况：输入序列已经是有序，遍历一遍即可，时间复杂度为$O(n)$。
- 最坏情况：输入序列完全逆序，每次插入都要移动元素，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**

- 当顺序表已经是有序时，每个元素只需比较一次，共n-1次。公式为：$C_{\text{min}}(n) = n - 1$。

**【最坏情况下的比较次数】**

- 当顺序表完全逆序时，第i个元素需要和前i-1个元素进行比较，共$\frac{n(n-1)}{2}$次。公式为：$C_{\text{max}}(n) = \frac{n(n-1)}{2}$。

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都使得表中元素局部有序

#### 折半插入排序

**【算法描述】**

1. 从第一个元素开始，该元素默认已经是有序区。
2. 取下一个元素，在有序区中使用二分查找找到合适的插入位置。
3. 插入到找到的位置，移动插入点后的元素。
4. 重复第2步和第3步，直到所有元素遍历完毕。

**【性能分析】**

- 最好情况：输入序列已经是有序，时间复杂度为$O(n)$。
- 最坏情况：输入序列完全逆序，需要进行多次二分查找，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**

- 当顺序表已经是有序时，每个元素只需通过二分查找法找到插入的位置，共$log_{2} n$次。公式为：$C_{\text{min}}(n) = \log_{2} n$。

**【最坏情况下的比较次数】**

- 当顺序表完全逆序时，每个元素都要通过二分查找法找到插入的位置，共$n\log_{2} n$次。公式为：$C_{\text{max}}(n) = n \log_{2} n$。

**【稳定性】**  稳定。

**【适用性】** 适用于顺序存储和链式存储。但由于涉及到元素的大量移动，链式存储的效率会降低。

**【过程特性】** 每趟都使得表中元素局部有序

#### 希尔排序

**【算法描述】**

1. 设置增量序列，如希尔增量：$d = n / 2, d = d / 2, \dots, d = 1$。
2. 按增量划分子序列，利用插入排序对子序列进行排序。
3. 缩小增量，重复第2步，直到增量为1。

**【性能分析】**

- 具体取决于所选的增量序列。

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。但是由于对子序列进行插入排序，链式存储的效率会降低。

**【过程特性】** 每趟都使得表中元素局部有序

### 8.3 交换排序

#### 冒泡排序

**【算法描述】**

1. 从数组的第一个元素开始，遍历数组，在相邻的元素中进行比较，如果逆序，则交换它们的位置。
2. 重复进行第1步，直到整个数组都有序。

**【性能分析】**

- 最好情况：输入序列已经是有序，遍历一遍即可，时间复杂度为$O(n)$。
- 最坏情况：输入序列完全逆序，需要进行n-1轮比较，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**

- 当顺序表已经是有序时，比较次数 n-1，移动次数 0。

**【最坏情况下的比较次数】**

- 当顺序表完全逆序时，比较次数 $\frac{n(n-1)}{2}$，移动次数 $\frac{3n(n-1)}{2}$

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都确保表中最大(最小)元素在其最终位置

#### 快速排序

**【算法描述】**

1. 选择一个基准元素（如数组的第一个元素）。
2. 将数组中的元素按照跟基准元素的比较结果进行分区（比基准元素小的在左边，大的在右边）。
3. 递归地分别对左右两边的子数组进行第2步，直到子数组只剩一个元素或空。

**【性能分析】**

- 最好情况：每次选取的基准元素将数组均分，时间复杂度为$O(n\log n)$。
- 最坏情况：每次选取的基准元素都是最大或最小，时间复杂度为$O(n^2)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 第i趟完成后，会有i个以上的元素出现在最终位置，即它左边的数比它小，右边的数比它大

### 8.4 选择排序

#### 简单选择排序

**【算法描述】**

1. 在待排序的序列中找到最小值。
2. 将找到的最小值替换序列中的第一个元素。
3. 从剩下未排序的序列中重复第1步与第2步，直到序列全部排序完毕。

**【性能分析】**

- 无论是最好还是最坏情况下，时间复杂度均为$O(n^2)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都确保表中最大(最小)元素在其最终位置

#### 堆排序

**【算法描述】**

1. 将无序序列构建成一个大顶堆（或小顶堆）。
2. 将堆顶元素与序列的最后一个元素交换。
3. 缩小待排序序列的范围，去掉最后一个元素，重新调整堆结构。
4. 重复第2步与第3步，直到整个序列排序完成。

**【性能分析】**

- 无论是最好还是最坏情况下，时间复杂度均为$O(n\log n)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 不稳定。

**【适用性】** 适用于顺序存储和链式存储。

**【过程特性】** 每趟都确保表中最大(最小)元素在其最终位置

### 8.5 二路归并排序

**【算法描述】**

1. 将待排序数组分成两个长度相等的子数组。
2. 递归地对两个子数组进行归并排序，直到每个子数组只剩下一个元素。
3. 将两个已排序的子数组合并成一个有序数组。

**【性能分析】**

- 无论是最好还是最坏情况下，时间复杂度均为$O(n\log n)$。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

### 8.6 基数排序

**【算法描述】** 

1. 根据元素的位数（比如个位、十位、百位等）从低到高进行排序。
2. 在每一位上，采用一个稳定的排序算法（如计数排序）对数字进行排序。
3. 对所有位数重复进行第1步与第2步，直到最高位排序完成。

**【性能分析】**

- 最好情况：输入序列中的元素分布均匀，时间复杂度为$O(d(n+r))$，k为最大元素的位数。
- 最坏情况：输入序列中的元素非常集中，需要进行额外的桶排序，时间复杂度仍为$O(d(n+r))$。
- 基数排序的时间复杂度中的d表示关键字的位数，r表示关键字的基数或者范围3。例如，如果关键字是十进制数，那么r=10，如果关键字是英文字母，那么r=26。

**【最好情况下的比较次数】**
...

**【最坏情况下的比较次数】**
...

**【稳定性】** 稳定。

**【适用性】** 适用于顺序存储和链式存储。

### 8.7 外部排序

**【外部排序的总时间】**

外部排序的总时间 = 内部排序所需时间 + 外存信息读写时间 + 内部归并所需时间

#### 多路平衡与败者树

**【算法描述】**

- 构建一个k路败者树，k表示归并的路数，败者树的叶子节点对应从输入缓冲区读取的顺序记录。
- 输赢规则：较小的数为胜者，较大的数为败者。
- 在败者树上选择胜者（最小记录），将胜者输出到输出缓冲区。
- 将胜者所在的归并段中的下一个顺序记录读取，并重新调整败者树结构。
- 当所有输如缓冲区数据合并完毕则结束外部排序。

**【比较次数】** 最多为$C = S \times (n-1) \times \lceil \log_2 k \rceil$，k为归并的路数。

#### 置换选择排序

**【算法描述】**

1. 初始化一个最小值，完成初始化准备。
2. 遍历所有输入缓冲区记录，选择大于当前最小值的最小记录，并输出到输出缓冲区。
3. 如果当前输入缓冲区读完，重新填充缓冲区。
4. 持续步骤2-3，直至输入缓冲区全部读完并且没有可以替换的记录。

**【比较次数】**

- 比较次数不确定，因为与输入数据密切相关。如果原始数据越接近有序，比较次数就越少。

#### 最佳归并树

【算法描述】

- 计算每个归并段的长度，作为权重。
- 使用霍夫曼树构建最佳归并树，使每个归并段完成的I/O次数最小。
- 将归并树的叶子节点按照顺序合并。

**【如何判断添加虚段的次数？】**

- 对于k路平衡归并来说，若(m-1)MOD(k-1)=0，则不需要增加虚段；否则需附加k-(m-1)MOD(k-1)-1个虚段。

### 8.8 排序算法的分析与应用

1. 冒泡排序 (Bubble Sort):
    - 适用场景：小规模数据，局部有序，链式存储。
    - 优点：实现简单，相邻数据交换，稳定。
    - 缺点：时间复杂度较高，不适用于大规模数据。

2. 选择排序 (Selection Sort):
    - 适用场景：小规模数据，对算法稳定性要求不高。
    - 优点：实现简单，无论数据如何都能保证最多$n-1$次数据交换。
    - 缺点：不稳定，不适应于有序和接近有序的数据。

3. 插入排序 (Insertion Sort):
    - 适用场景：小规模数据，接近有序。
    - 优点：实现简单，时间复杂度在接近有序数据时较低，稳定。
    - 缺点：不适用于大规模数据。

4. 快速排序 (Quick Sort):
    - 适用场景：大规模数据，速度较快。
    - 优点：平均时间复杂度较低，为$O(n\log n)$，适用于各种内存储结构。
    - 缺点：最坏情况时间复杂度较高，为$O(n^2)$，不稳定。

5. 归并排序 (Merge Sort):
    - 适用场景：大规模数据，稳定性要求较高。
    - 优点：时间复杂度为$O(n\log n)$，适用于各种内存储结构，稳定。
    - 缺点：辅助空间消耗较高，需要额外的空间来完成归并操作。

6. 堆排序 (Heap Sort):
    - 适用场景：大规模数据，要求原地排序。
    - 优点：时间复杂度为$O(n\log n)$，适用于各种内存储结构，原地排序。
    - 缺点：不稳定，局部排序性较差。

7. 希尔排序 (Shell Sort):
    - 适用场景：中等规模数据。
    - 优点：对插入排序的改进，适用于增量序列较小的情况，实现相对简单。
    - 缺点：增量序列的选择对算法性能有较大影响，不稳定。

8. 基数排序 (Radix Sort):
    - 适用场景：数据长度较大，元素分布已知。
    - 优点：时间复杂度较低，稳定。
    - 缺点：辅助空间消耗较高，需要额外的空间来分配元素到相应的序列中。
